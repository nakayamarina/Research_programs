install.package("R6")
install.packages("R6")
Japan
library(R6)
Q
quit
quit()
install.packages(c('repr', 'IRdisplay', 'evaluate', 'crayon', 'pbdZMQ', 'devtools', 'uuid', 'digest'))
devtools::install_github('IRkernel/IRkernel')
devtools::install_github('IRkernel/IRkernel')
install.packages(c('repr', 'IRdisplay', 'crayon', 'pbdZMQ', 'devtools'))
devtools::install_github('IRkernel/IRkernel')
setwd("~/Documents/nakayama/Research/Research_programs")
library(TDA)
library(scatterplot3d)
PATH <- '../tameshi/20170130ar/12ch/RawData/'
ms<- 2
DIR_attractor <- paste(PATH, 'TDAvec_autocor_attractor', sep="")
NotHole <- 2
PATH_rest <- paste(PATH, 'raw_rest.csv', sep = "")
PATH_tap <- paste(PATH, 'raw_tap.csv', sep = "")
PATH_tau <- paste(PATH, 'TAUautocor.csv', sep = "")
# csvファイルの読み込み
rest <- read.csv(PATH_rest)
tap <- read.csv(PATH_tap)
taus <- read.csv(PATH_tau)
PATH <- '../Data_block/analysis_by_programs//20170130ar/12ch/RawData/'
PATH_rest <- paste(PATH, 'raw_rest.csv', sep = "")
PATH_tap <- paste(PATH, 'raw_tap.csv', sep = "")
PATH_tau <- paste(PATH, 'TAUautocor.csv', sep = "")
# csvファイルの読み込み
rest <- read.csv(PATH_rest)
tap <- read.csv(PATH_tap)
taus <- read.csv(PATH_tau)
i = 1
# i番目のボクセルデータ
voxel_rest <- rest[i]
voxel_tap <- tap[i]
# i番目のボクセルの時間遅れτ
tau_rest <- taus[i, 1]
tau_tap <- taus[i, 2]
Attractor <- function(voxel, tau, voxel_no, task){
# データをずらすことで長さが変わるので注意！
# 元データ
x <- voxel[1:(nrow(voxel) - (2*tau)), 1]
# 元データからτ分ずらしたデータ
y <- voxel[(1 + tau):(nrow(voxel) - (tau)), 1]
# 元データから2*τ分ずらしたデータ
z <- voxel[(1 + (2*tau)):nrow(voxel), 1]
# 3次元データとして結合
xyz <- cbind(x, y, z)
return (xyz)
}
attractor_rest <- Attractor(voxel_rest, tau_rest, i, "Rest")
attractor_tap <- Attractor(voxel_tap, tau_tap, i, "Tapping")
View(attractor_rest)
View(attractor_tap)
View(attractor_rest)
attractor <- attractor_rest
tda <- ripsDiag(X = attractor, maxdimension = 2, maxscale = ms)
df_tda <- as.data.frame(tda$diagram[, 1:3])
View(df_tda)
# ベクトル化する穴の種類
# 使わないもの（使う穴が2つの場合）
NotHole <- 10
# or
# 使うもの（使う穴が1つの場合）
UseHole <- 10
# 設定する．設定しない場合は10とかにする
# 各次の穴情報を分割
zeroDim <- subset(df_tda, df_tda$dimension == 0)
oneDim <- subset(df_tda, df_tda$dimension == 1)
twoDim <- subset(df_tda, df_tda$dimension == 2)
# 各次の穴の数を数え横結合することでベクトル化
if (NotHole == 0 && UseHole == 10){
tdaVec <- c(BettiNumberCount(oneDim), BettiNumberCount(twoDim))
} else if (NotHole == 1 && UseHole == 10) {
tdaVec <- c(BettiNumberCount(zeroDim), BettiNumberCount(twoDim))
} else if (NotHole == 2 && UseHole == 10) {
tdaVec <- c(BettiNumberCount(zeroDim), BettiNumberCount(oneDim))
} else if (UseHole == 0 && NotHole == 10) {
tdaVec <- c(BettiNumberCount(zeroDim))
} else if (UseHole == 1 && NotHole == 10) {
tdaVec <- c(BettiNumberCount(oneDim))
} else if (UseHole == 2 && NotHole == 10) {
tdaVec <- c(BettiNumberCount(twoDim))
} else {
tdaVec <- c(BettiNumberCount(zeroDim), BettiNumberCount(oneDim), BettiNumberCount(twoDim))
}
BettiNumberCount <- function(hole){
# 穴をkizamiNumber回数えるために時間幅を求める
# もともとの時間はms，kizamiNumberで割ることでどれぐらいずつ時刻timeをずらせばいいかわかる
kizamiWidth <- ms/kizamiNumber
# 時刻
time <- 0
# 穴を数えた回数
k <- 0
# kizamiNumber回数えた結果を格納する配列
bettiNumbers <- c()
# 穴が発生していればTrue
if(nrow(hole) >= 1){
# kizamiNumber回穴の数を数えるまでループ
while(k != kizamiNumber){
# 時刻timeの時の穴の数
bettiCount <- 0
# 発生したそれぞれの穴に対して調べる
for(j in 1:nrow(hole)){
# 時刻timeがある穴の発生時間中（Birth <= time <= Death）であればbettiCountに1足す
if((hole$Birth[j] <= time) && (time <= hole$Death[j])){
bettiCount = bettiCount + 1
}
}
# bettiCountを配列に格納
bettiNumbers <- c(bettiNumbers, bettiCount)
# 時刻timeをずらす
time = time + kizamiWidth
# 穴の数を数えたのでkに1足す
k = k + 1
}
} else {
# そもそも穴が発生していなければ0をkizamiNumber個格納
bettiNumbers <- numeric(kizamiNumber)
}
return(bettiNumbers)
}
# 各次の穴の数を数え横結合することでベクトル化
if (NotHole == 0 && UseHole == 10){
tdaVec <- c(BettiNumberCount(oneDim), BettiNumberCount(twoDim))
} else if (NotHole == 1 && UseHole == 10) {
tdaVec <- c(BettiNumberCount(zeroDim), BettiNumberCount(twoDim))
} else if (NotHole == 2 && UseHole == 10) {
tdaVec <- c(BettiNumberCount(zeroDim), BettiNumberCount(oneDim))
} else if (UseHole == 0 && NotHole == 10) {
tdaVec <- c(BettiNumberCount(zeroDim))
} else if (UseHole == 1 && NotHole == 10) {
tdaVec <- c(BettiNumberCount(oneDim))
} else if (UseHole == 2 && NotHole == 10) {
tdaVec <- c(BettiNumberCount(twoDim))
} else {
tdaVec <- c(BettiNumberCount(zeroDim), BettiNumberCount(oneDim), BettiNumberCount(twoDim))
}
kizamiNumber <- 300
# 各次の穴の数を数え横結合することでベクトル化
if (NotHole == 0 && UseHole == 10){
tdaVec <- c(BettiNumberCount(oneDim), BettiNumberCount(twoDim))
} else if (NotHole == 1 && UseHole == 10) {
tdaVec <- c(BettiNumberCount(zeroDim), BettiNumberCount(twoDim))
} else if (NotHole == 2 && UseHole == 10) {
tdaVec <- c(BettiNumberCount(zeroDim), BettiNumberCount(oneDim))
} else if (UseHole == 0 && NotHole == 10) {
tdaVec <- c(BettiNumberCount(zeroDim))
} else if (UseHole == 1 && NotHole == 10) {
tdaVec <- c(BettiNumberCount(oneDim))
} else if (UseHole == 2 && NotHole == 10) {
tdaVec <- c(BettiNumberCount(twoDim))
} else {
tdaVec <- c(BettiNumberCount(zeroDim), BettiNumberCount(oneDim), BettiNumberCount(twoDim))
}
NotHole <- 2
# 各次の穴の数を数え横結合することでベクトル化
if (NotHole == 0 && UseHole == 10){
tdaVec <- c(BettiNumberCount(oneDim), BettiNumberCount(twoDim))
} else if (NotHole == 1 && UseHole == 10) {
tdaVec <- c(BettiNumberCount(zeroDim), BettiNumberCount(twoDim))
} else if (NotHole == 2 && UseHole == 10) {
tdaVec <- c(BettiNumberCount(zeroDim), BettiNumberCount(oneDim))
} else if (UseHole == 0 && NotHole == 10) {
tdaVec <- c(BettiNumberCount(zeroDim))
} else if (UseHole == 1 && NotHole == 10) {
tdaVec <- c(BettiNumberCount(oneDim))
} else if (UseHole == 2 && NotHole == 10) {
tdaVec <- c(BettiNumberCount(twoDim))
} else {
tdaVec <- c(BettiNumberCount(zeroDim), BettiNumberCount(oneDim), BettiNumberCount(twoDim))
}
kizamiNumber <- 100
# 各次の穴の数を数え横結合することでベクトル化
if (NotHole == 0 && UseHole == 10){
tdaVec <- c(BettiNumberCount(oneDim), BettiNumberCount(twoDim))
} else if (NotHole == 1 && UseHole == 10) {
tdaVec <- c(BettiNumberCount(zeroDim), BettiNumberCount(twoDim))
} else if (NotHole == 2 && UseHole == 10) {
tdaVec <- c(BettiNumberCount(zeroDim), BettiNumberCount(oneDim))
} else if (UseHole == 0 && NotHole == 10) {
tdaVec <- c(BettiNumberCount(zeroDim))
} else if (UseHole == 1 && NotHole == 10) {
tdaVec <- c(BettiNumberCount(oneDim))
} else if (UseHole == 2 && NotHole == 10) {
tdaVec <- c(BettiNumberCount(twoDim))
} else {
tdaVec <- c(BettiNumberCount(zeroDim), BettiNumberCount(oneDim), BettiNumberCount(twoDim))
}
# BettiNumberCount関数で使う穴を数える回数
kizamiNumber <- 100
# ベクトル化する穴の種類
# 使わないもの（使う穴が2つの場合）
NotHole <- 10
# or
# 使うもの（使う穴が1つの場合）
UseHole <- 10
# 設定する．設定しない場合は10とかにする
if (NotHole == 0 && UseHole == 10){
Pattern <- 1
} else if (NotHole == 1 && UseHole == 10) {
Pattern <- 2
} else if (NotHole == 2 && UseHole == 10) {
Pattern <- 3
} else if (UseHole == 0 && NotHole == 10) {
Pattern <- 4
} else if (UseHole == 1 && NotHole == 10) {
Pattern <- 5
} else if (UseHole == 2 && NotHole == 10) {
Pattern <- 6
} else {
Pattern <- 7
}
TDAvec <- function(attractor, voxel_no, task){
# TDAのPersistent Homologyを適用
tda <- ripsDiag(X = attractor, maxdimension = 2, maxscale = ms)
# 穴情報を抽出
df_tda <- as.data.frame(tda$diagram[, 1:3])
# 各次の穴情報を分割
zeroDim <- subset(df_tda, df_tda$dimension == 0)
oneDim <- subset(df_tda, df_tda$dimension == 1)
twoDim <- subset(df_tda, df_tda$dimension == 2)
# 各次の穴の数を数え横結合することでベクトル化
if (Pattern == 1){
tdaVec <- c(BettiNumberCount(oneDim), BettiNumberCount(twoDim))
} else if (Pattern == 2) {
tdaVec <- c(BettiNumberCount(zeroDim), BettiNumberCount(twoDim))
} else if (Pattern == 3) {
tdaVec <- c(BettiNumberCount(zeroDim), BettiNumberCount(oneDim))
} else if (Pattern == 4) {
tdaVec <- c(BettiNumberCount(zeroDim))
} else if (Pattern == 5) {
tdaVec <- c(BettiNumberCount(oneDim))
} else if (Pattern == 6) {
tdaVec <- c(BettiNumberCount(twoDim))
} else if (Pattern == 7) {
tdaVec <- c(BettiNumberCount(zeroDim), BettiNumberCount(oneDim), BettiNumberCount(twoDim))
}
return(tdaVec)
}
# 各次の穴の数を数え横結合することでベクトル化
if (Pattern == 1){
tdaVec <- c(BettiNumberCount(oneDim), BettiNumberCount(twoDim))
} else if (Pattern == 2) {
tdaVec <- c(BettiNumberCount(zeroDim), BettiNumberCount(twoDim))
} else if (Pattern == 3) {
tdaVec <- c(BettiNumberCount(zeroDim), BettiNumberCount(oneDim))
} else if (Pattern == 4) {
tdaVec <- c(BettiNumberCount(zeroDim))
} else if (Pattern == 5) {
tdaVec <- c(BettiNumberCount(oneDim))
} else if (Pattern == 6) {
tdaVec <- c(BettiNumberCount(twoDim))
} else if (Pattern == 7) {
tdaVec <- c(BettiNumberCount(zeroDim), BettiNumberCount(oneDim), BettiNumberCount(twoDim))
}
if (NotHole == 0 && UseHole == 10){
Pattern <- 1
parameters <- paste(kizamiNumber, "_", "12dim", sep="")
} else if (NotHole == 1 && UseHole == 10) {
Pattern <- 2
parameters <- paste(kizamiNumber, "_", "02dim", sep="")
} else if (NotHole == 2 && UseHole == 10) {
Pattern <- 3
parameters <- paste(kizamiNumber, "_", "01dim", sep="")
} else if (UseHole == 0 && NotHole == 10) {
Pattern <- 4
parameters <- paste(kizamiNumber, "_", "0dim", sep="")
} else if (UseHole == 1 && NotHole == 10) {
Pattern <- 5
parameters <- paste(kizamiNumber, "_", "1dim", sep="")
} else if (UseHole == 2 && NotHole == 10) {
Pattern <- 6
parameters <- paste(kizamiNumber, "_", "2dim", sep="")
} else {
Pattern <- 7
parameters <- paste(kizamiNumber, "_", "012dim", sep="")
}
parameters
PATH_restVec <- paste(PATH, 'TDAvec_autocor_rest_', parameters, '.csv', sep = "")
PATH_restVec
messe <- paste('----- excution voxel.', i, ' ---')
pritn(messe)
messe <- paste('----- excution voxel.', i, ' ---')
print(messe)
